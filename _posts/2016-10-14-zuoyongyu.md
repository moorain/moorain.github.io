---
layout: post
title: JS中的作用域，作用域链
category: JavaScript
tags: [JavaScript]
excerpt:  "执行环境(Execution Contexts)也被翻译为执行上下文，当解析器进入ECMAScript的可执行代码，解析器就进入一个执行环境，活动的执行环境组成一个逻辑上的栈，在这个逻辑栈顶部的执行环境是当前运行的执行环境。"
---
<h2>{{ page.title }}</h2>
{% include date.html%}
<p class="zhai">摘要：执行环境(Execution Contexts)也被翻译为执行上下文，当解析器进入ECMAScript的可执行代码，解析器就进入一个执行环境，活动的执行环境组成一个逻辑上的栈，在这个逻辑栈顶部的执行环境是当前运行的执行环境。</p>

### 1.执行环境的概念 ###

在js中，**执行环境（execution context）**是一个非常重要的概念。


执行环境(Execution Contexts)也被翻译为**执行上下文**，当解析器进入ECMAScript的可执行代码，解析器就进入一个执行环境，活动的**执行环境组成一个逻辑上的栈**，在这个逻辑栈顶部的执行环境是当前运行的执行环境。  
程序代码运行时，会产生一个专门用来管理所需的变量和函数的对象---环境对象，这个对象我们不能通过代码编写操作他，但解析器在处理数据时会在后台使用他。


注：ECMAScript中有三种可执行代码，**Global、Function和Eval，**全局环境即是Global可执行代码，函数即是Function可执行代码。逻辑栈是一种特殊的数据存储格式，特点是‘先进后出，后进先出'，添加数据会先压入逻辑栈顶部，删除数据必须先从顶部开始删除。

![](http://files.jb51.net/file_images/article/201607/201675145052363.jpg?20166514515)  
变量对象(Variable Object)、活动对象(Activation Object)和Arguments对象(Arguments Object)    
每个执行环境都有一个与之关联的变量对象，当解析器进入执行环境时，就会创建一个变量对象，变量对象**保存着在当前执行环境中声明的变量和函数的引用**。

变量对象是一个抽象的概念，在不同的执行环境中，变量对象有不同的身份，在解析器进入任何执行环境之前，就已经创建了一个Global对象，当解析器进入全局执行环境时，**Global对象就充当变量对象**，当解析器进入一个函数时，就会创建一个**活动对象充当变量对象**。


#### 全局执行环境 ####
全局环境就是最外围的一个执行环境，可以在代码任意位置访问到。在浏览器中，全局环境就是window对象（因此，所有的全局变量和函数，都是window对象上的属性和方法）。  
全局环境也称全局作用域。
#### 局部环境 ####
局部环境以**函数为主**。每个函数都有自己独立的执行环境。  
局部作用域一般只在固定的代码片段内可访问到，最常见的就是函数内部，所以在很多地方就会有人把它称为**函数作用域**。  

### 2.解析器处理代码时的两个阶段 ###

我们都知道javascript解析器是一段一段解析处理代码的，为什么？这就要涉及解析器处理代码时的两个阶段，解析代码和执行代码。  
当解析器进入执行环境时，变量对象就会添加执行环境中声明的变量和函数作为它的属性，这就意味着变量和函数在声明之前已经可用，变量值为undefined，这就是**变量和函数声明提升(Hoisting)**的原因，与此同时作用域链和this确定，此过程为**解析阶段**，俗称预解析。

接着解析器开始执行代码，为变量添加相应值的引用，得到执行结果，此过程为**执行阶段**。
	
	var a=123;
	var b="abc";
	function c(){
	  alert('11');
	}

上述全局环境中的代码解析执行后，会将Global对象作为变量对象，保存以下数据。

![](http://files.jb51.net/file_images/article/201607/201675145144397.jpg?201665145154)


	function testFn(a){
	  var b="123";
	  function c(){
	    alert("abc");
	  }
	}
	  
	testFn(10);

当解析器进入函数执行环境时，则会**创建一个活动对象作为变量对象**，活动对象还会创建一个Arguments对象，arguments对象是一个参数集合，用来保存参数，这就是我们写函数时可以使用arguments[0]等来使用参数的原因。

![](http://files.jb51.net/file_images/article/201607/201675145319913.jpg?201665145328)

### 3.作用域链(Scope Chain) ###
每个执行环境都有一个与之关联的作用域链，当解析器进入执行环境时被定义，作用域链是一个对象列表，用来检索各个变量对象中的变量和函数，这样可以保证执行环境有权访问哪些变量和函数，举个栗子。
	
	var a='123';
	function testFn(b){
	  var c='abc';

	  function testFn2(){
	    var d='efg';
	    alert(a);
	  }
	  
	  testFn2();
	} 
	testFn(10);

testFn2内未声明变量a，为什么testFn2能调用全局变量a？整个过程是怎么发生的呢？请看下图。
![](http://files.jb51.net/file_images/article/201607/201675145344904.jpg?201665145353)  
当解析器进入全局执行环境时，调用变量和函数时只在Global对象中查找。

当解析器进入testFn函数执行环境时，函数内部属性[[scope]]中首先填入Global对象，然后将testFn活动对象添加到Global对象之前，形成一个作用域链。

![](http://files.jb51.net/file_images/article/201607/201675145416219.jpg?201665145428)

当解析器进入testFn2函数执行环境时，函数内部属性[[scope]]首先填入父级的作用域链，然后再将当前的testFn2活动对象添加到作用域链的前端，形成一个新的作用域链。  

testFn2调用变量a时，首先在当前的testFn2活动对象中查找，如果没有找到就顺着作用域链向上，在testFn活动对象中查找变量a，如果没有找到再顺着作用域链向上查找，直到在最后Global对象中找到为止，否则报错。所以函数内部可以调用外部环境的变量，外部环境不能调用函数内部的变量，这就是作用域特性的原理。

> DenGo 
