---
layout: post
title: 关于闭包的理解
category: JavaScript
tags: [JavaScript]
excerpt: "闭包就是一种作用域的体现，体现函数内的变量可以访问函数外的数据，正常情况下函数外的语句不能访问函数内的变量，可以通过闭包解决这个问题。闭包其实是一种跨作用域访问数据的方式。"
---
<h2>{{ page.title }}</h2>
<p class="zhai">摘要：闭包就是一种作用域的体现，体现函数内的变量可以访问函数外的数据，正常情况下函数外的语句不能访问函数内的变量，可以通过闭包解决这个问题。闭包其实是一种跨作用域访问数据的方式。</p>
<!--<p>{{ page.date | date_to_string }}</p>-->
### 什么是闭包？ ###
闭包其实是一种跨作用域访问数据的方式。  
闭包就是一种**作用域的体现**，体现函数内的变量可以访问函数外的数据，正常情况下函数外的语句不能访问函数内的变量，可以通过闭包解决这个问题。
### 闭包有什么用？ ###
所有**跨作用域访问数据**的应用：记不重复的计数器、封装...
### 闭包的写法？ ###
	//第一种：直接将内部函数暴露给全局
	(function(){
		var i=0;
		window.aaa=function(){
			return ++i;
		};
	})();

	//第二种： 将函数执行的结果返回
		var aaa=(function(){
			var i=0;//在内存中定义一个变量
			return function(){
				return ++i;
			}
		})();

		//执行完一遍后将自身代码更改为:
		var aaa=function(){
				return ++i;
		};
此时变量i还存在内存中。内部函数可以访问i  然后再将结果返回给aaa;
其中变量i永久封闭，其他函数不能访问，只有aaa能访问，此方法可以彻底的将变量i封闭起来。 
这也是一种闭包的形式。 闭包还有很多种形式。

### 闭包的实现原理举例1 ###

	//需求：制作一个永不重复的计数器
	一般做法：
	var i=0;
	function count(){
		return ++i;
	}
	
	console.log( count() );
	console.log( count() );
	i=0; //可以对全局变量进行修改，无法实现永不重复
	console.log( count() );
	console.log( count() );
	console.log( count() );

使用闭包实现：

	//使用闭包来实现：
	(function(){
		var i=0;//在内存中定义一个变量
		window.aaa=function(){
			return ++i;
		};
	})();	
	
	console.log( aaa() );
	console.log( aaa() );
	i=0;
	console.log( aaa() );
	console.log( aaa() );
	console.log( aaa() );

实现原理如下图：

![](https://i.imgur.com/hQ9iAAV.png)

内层函数可以访问外层函数的数据，外层函数可以访问全局作用域内的数据。按照正常的逻辑，全局是不能访问内部的函数的，但是，将内部函数count挂载到全局上（window.aaa），此时aaa又是function的内部函数，又是全局函数。  
这样就产生了一种特殊的结构，这种特殊的语法结构就是**闭包**。

上例，内部函数count（也就是aaa）的数据来自它的外层函数，也就是说它可以访问到i = 0。  
但此时aaa又是window一个全局指向的位置，count（也就是aaa）又可以被全局所调用。  
所以在全局作用域下，可以访问到内部函数count，也就是实例中的aaa作用域中的数据。   
<br> 
将内部函数count赋给全局之后，全局可以访问到count，然后内部函数count可以访问到它的外层函数function作用域的数据。由此，就可以实现全局下访问函数作用域的数据，形成闭包。

### 闭包的实现原理举例2 ###

	//需求:制作一个定时器，每秒按顺序输出12345; 
	for(var i=1; i<=5; i++){
		(function(i){
			setTimeout(function(){
				console.log(i);
			},1000*i);
		})(i);
	}
		
如果不封装setTimeout代码,内部函数访问的作用域是全局变量,此时内部函数只能得到循环过后的i值,此时i = 6。		  
解决办法是用IIFE立即执行函数表达式将setTimeout代码封装起来,使其有一个独立的作用域。  
for循环每次循环一次,将会开启一个函数作用域,传入一个i值参与运行,此时的i值就是这个局部作用域的局部变量。这样也形成了闭包。
### 总结 ###


闭包的特征：

1. 函数内嵌套函
2. 正常情况下函数内可以访问函数外的数据，函数外不能访问函数内的数据
3. 可以将内部函数暴露到全局上，或者返回给全局变量，实现外部可以访问函数内部的数据
4. 由于函数内的数据被全局所占用，延缓资源的回收



