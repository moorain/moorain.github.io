---
layout: post
title: JS高阶-关于原型prototype
category: JS高阶
tags: [JS高阶]
excerpt:  "构造函数在创建一个新的实例时，每个方法都重新创建了一遍。这种方式创建函数，会导致不同的作用域链和标识符解析，创建function的新实例的机制仍然是相同的，因此，不同实例上的同名函数是不相等的，但是创建两个完成同样任务的function实例完全没有必要。"
---
<h2>{{ page.title }}</h2>
{% include date.html%}
<p class="zhai">摘要：构造函数在创建一个新的实例时，每个方法都重新创建了一遍。这种方式创建函数，会导致不同的作用域链和标识符解析，创建function的新实例的机制仍然是相同的，因此，不同实例上的同名函数是不相等的，但是创建两个完成同样任务的function实例完全没有必要。</p>
# 对象原型Prototype #

### 1.构造函数 ###
要理解prototype 首先我们来看一个构造函数：  
创建一个小猫构造函数，代码如下：
	
	function Cat(name,color){
		this.name = name;
		this.color = color;
		this.run=function(){
		    alert(“一只”+this.color +"的小猫飞奔过来...");
		}
		this.eat=function(){
		    alert(this.name +"要吃鱼");
		}
	}
	var cat1 = new Cat();

以上所有用this定义方法，this代表新的实例，都会在创建新实例时为其创建一个方法副本。
每个方法都要重新创建一遍，占用了不必要的内存空间，造成了资源浪费。这肯定不是我们想看到的。

#### 怎么解决呢？ ####
构造函数在创建一个新的实例时，每个方法都重新创建了一遍。这种方式创建函数，会导致不同的作用域链和标识符解析，创建function的新实例的机制仍然是相同的，因此，不同实例上的同名函数是不相等的，但是创建两个完成同样任务的function实例完全没有必要。  
解决方法是利用在原型Prototype上创建让对象实例可以共享的属性和方法。
#### 原型Prototype ####

**JavaScript的所有function 类型的对象都有一个prototype属性**。 这个prototype属性本身又是一个object类型的对象， 因此也可以给这个prototype对象添加任意的属性和方法。

代码如下：

	function Cat(name,color){
		this.name = name;
		this.color = color;
	}
	//定义原型方法
	Cat.prototype.run=function(){
		 alert("一只"+this.color +"的小猫飞奔过来...");
	}
	Cat.prototype.eat=function(){
		 alert(this.name +"要吃鱼");
	}	
	var cat1 = new Cat("aa","white");
	var cat2 = new Cat("aa","black");
	console.log(cat1)
	console.log(cat2)
输出的结果：  

![](https://i.imgur.com/QpL27rp.jpg)
> 
> **这里再为——proto——做一个说明**（编辑器的缘故，这里的——为双下划线）：  
> 
> 对象具有属性——proto——，可称为隐式原型，**一个对象的隐式原型指向构造该对象的构造函数的原型**，这也保证了实例能够访问在构造函数原型中定义的属性和方法(在firefox、safari、chorme支持这个属性)。

好了，回到上图中，可以看到，创建的实例的原型对象上，有eat 和 run的方法。创建多个实例时，原型对象上的方法或属性将会被所有实例共享。

**每一个类（构造函数）都具有一个prototype属性**，当创建这个类的实例对象时，原型对象的所有属性或方法都被立即赋予要创建的实例对象中。

所以 接下来 对原型对象做一个说明：


### 2.原型对象prototype ###
#### 1.什么是原型prototype？  ####

在JS中，**所有使用function 定义的函数都具备原型属性**，prototype属性又是一个对象类型，所以可以添加自定义的属性和方法（原型方法）

#### 2.原型prototype有什么用？ ####
1. 添加自定义的属性和方法（原型方法）
2. 对类的功能进行扩展
3. 解决方法过载的问题，也就是上面提到的内存资源浪费的问题

#### 3.如何使用？ ####
因为prototype也是一个对象，我们可以直接在后添加属性和方法。语法代码：

	类名.prototype.方法名=function(){}

### __proto__ 和prototype的区别 ###
1. ——proto——只出现在对象上，实际上是对 类的原型prototype 属性的引用
2. prototype出现在类的属性列表中

代码示例如下：

		function Dog(name,speed){
				this.name=name;
				this.speed=speed;
		}	
		//定义原型方法
		Dog.prototype.run=function(){
			console.log(this.name +'以每小时'+this.speed+'公里的速度跑步');
		}		
		var d1=new Dog('小白',20);
		var d2=new Dog('小黑',80);
		console.dir(d1.__proto__ === Dog.prototype);//true
		console.dir(d2.__proto__ === Dog.prototype);//true


### 3.属性和方法的查找顺序 ###


对象  >  类、构造函数  > 原型  > 原型链

	//构造函数、类
	function Dog(name,speed,age){
		this.name=name;
		this.speed=speed;
		//this.age=age; //其次在类的成员属性中找
		this.show=function(){};
	}
	//原型
	Dog.prototype.run=function(){
		console.log(this.name +'以每小时'+this.speed+'公里的速度跑步');
	}
	//Dog.prototype.age=14; //最后到原型上找
	
	var d1=new Dog('小白',20,12); //对象
	//d1.age=10; //查找顺序：首先在对象自身上找
	
	console.log(d1.age);
	console.log(Dog.toString()); //在Function上才能找到 toString方法