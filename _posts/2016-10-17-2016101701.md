---
layout: post
title: JS高阶-模块化编程
category: JS高阶
tags: [JS高阶]
excerpt: "由于对象上的属性是全公开的，任何人都可以访问或修改，存在安全等问题，而且有时候关乎隐私。于是，我们需要进行封装。"
---
<h2>{{ page.title }}</h2>
<p class="zhai">摘要：
由于对象上的属性是全公开的，任何人都可以访问或修改，存在安全等问题，而且有时候关乎隐私。于是，我们需要进行封装。 。</p>
<!--<p>{{ page.date | date_to_string }}</p>-->
### 为什么要使用模块化 ###
Web前端技术在不断发展，在我们浏览器界面越来越炫的同时，前端的代码也越来越复杂。动不动则**要引入大量的JavaScript外部代码**。

传统开发方式做项目就和堆积木一样，越堆越高。从而带来的维护成本也是相当昂贵的。

所以需要对原来的开发方式进行改变。使用模块化来解决它。

**1.多人项目中的变量函数名冲突**
函数的命名冲突，变量的名称冲突  是非常严重的问题。

解决方案： 使用命名空间。可以打包一堆定义。

	// itsource.js
	var cn= {};
	cn.Itsource={};
	cn.Itsource.Utils ={};
	cn.Itsource.fn.utils.show =function(){
	   console.log(‘我是ITSOURCE的show方法’);
	};

但还是有一些问题，容易写错。记忆成本很高，占用空间，非常不方便。
因为对象的读写数据都是开放的，安全性也不高。
所以种方式也有很大的问题。
**2.引入项目依赖过多**

在项目开发中，需要引入大量的依赖：如组件 插件等。
而且每个依赖的引入顺序也有一些问题。  
而且其中任意一个依赖出错，会导致整个页面出错。
每个外部依赖都会发送一次请求，请求过多也会成为页面加载的负担

于是，我们迫切需要**采用更高端的方法来搞定这些问题——模块化**。




### 模块化的演变 ###

1.模块模式--孵化期













### requirejs ###

**1.什么是requirejs？**
  
requirejs是一个使AMD规范实现模块化加载的框架，

**2.requirejs的三个函数**
	define：定义模块  
	require：使用模块  
	requirejs：同上  


**define**：

	define(模块名,依赖列表,回调函数)
	//前两个参数可选。回调函数必需

**require**
	
	require(依赖列表，回调函数）

**requirejs**
	同上

**3.使用requirejs** 

a.引入requirejs引擎文件
	
	sc
b.创建模块

	define（模块名，依赖列表，function（）｛
		//模块内容
	｝）；

c.使用模块


	require（模块列表，function(){
		//代码逻辑
	}）